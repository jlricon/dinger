<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0d0d0d">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<title>Dinger</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap');

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #0d0d0d;
    color: #a0a0a0;
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem 1rem;
    -webkit-font-smoothing: antialiased;
  }

  .container {
    width: 100%;
    max-width: 320px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2.5rem;
  }

  h1 {
    font-size: 1rem;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: #999;
  }

  /* --- Countdown --- */
  #countdown {
    font-size: 3.5rem;
    font-weight: 300;
    color: #e8e8e8;
    font-variant-numeric: tabular-nums;
    min-height: 4rem;
    letter-spacing: 0.02em;
  }

  #countdown:empty::after {
    content: "\00b7";
    color: #666;
  }

  #ding-progress {
    font-size: 0.75rem;
    color: #888;
    font-weight: 300;
    min-height: 1.2em;
  }

  /* --- Sound selector --- */
  .sound-row {
    display: flex;
    gap: 1.5rem;
  }

  .sound-btn {
    background: none;
    border: none;
    color: #888;
    font-family: inherit;
    font-size: 0.8rem;
    font-weight: 400;
    letter-spacing: 0.05em;
    cursor: pointer;
    padding: 0.4rem 0;
    border-bottom: 1px solid transparent;
    transition: color 0.2s, border-color 0.2s;
  }

  .sound-btn:hover { color: #bbb; }
  .sound-btn.selected {
    color: #d8d8d8;
    border-bottom-color: #d8d8d8;
  }

  /* --- Settings row --- */
  .settings {
    display: flex;
    align-items: baseline;
    gap: 1.5rem;
  }

  .setting {
    display: flex;
    align-items: baseline;
    gap: 0.4rem;
  }

  .setting input {
    background: none;
    border: none;
    border-bottom: 1px solid #555;
    color: #e8e8e8;
    font-family: inherit;
    font-size: 1.5rem;
    font-weight: 300;
    width: 3rem;
    text-align: center;
    padding: 0.25rem 0;
    outline: none;
    transition: border-color 0.2s;
  }

  .setting input:focus {
    border-bottom-color: #888;
  }

  .setting span {
    font-size: 0.85rem;
    color: #999;
    font-weight: 300;
  }

  /* --- Controls --- */
  .controls {
    display: flex;
    gap: 2rem;
  }

  .ctrl-btn {
    background: none;
    border: 1px solid #555;
    color: #aaa;
    font-family: inherit;
    font-size: 0.8rem;
    font-weight: 400;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 0.6rem 1.8rem;
    border-radius: 2rem;
    cursor: pointer;
    transition: color 0.2s, border-color 0.2s;
  }

  .ctrl-btn:hover:not(:disabled) {
    color: #e8e8e8;
    border-color: #888;
  }

  .ctrl-btn:disabled {
    opacity: 0.4;
    cursor: default;
  }

  /* --- Status --- */
  #status {
    font-size: 0.75rem;
    color: #888;
    text-align: center;
    min-height: 1.2em;
    font-weight: 300;
    letter-spacing: 0.03em;
  }
</style>
</head>
<body>

<div class="container">
  <h1>Dinger</h1>

  <div style="text-align:center">
    <div id="countdown"></div>
    <div id="ding-progress"></div>
  </div>

  <div class="sound-row">
    <button class="sound-btn" data-sound="bell">Bell</button>
    <button class="sound-btn" data-sound="bowl">Singing Bowl</button>
  </div>

  <div class="settings">
    <div class="setting">
      <input type="number" id="interval" min="1" step="1" value="5">
      <span>min</span>
    </div>
    <div class="setting">
      <input type="number" id="dings" min="1" step="1" value="3">
      <span>dings</span>
    </div>
  </div>

  <div class="controls">
    <button class="ctrl-btn" id="startBtn">Start</button>
    <button class="ctrl-btn" id="stopBtn" disabled>Stop</button>
  </div>

  <div id="status"></div>
</div>

<audio id="audio-bell" preload="auto" src="140128__jetrye__bell-meditation_cleaned.wav"></audio>
<audio id="audio-bowl" preload="auto" src="freesound_community-singing-bowl-hit-3-33366.mp3"></audio>

<script>
const SOUND_URLS = {
  bell: "140128__jetrye__bell-meditation_cleaned.wav",
  bowl: "freesound_community-singing-bowl-hit-3-33366.mp3",
};

const SOUND_LABELS = { bell: "Bell", bowl: "Singing Bowl" };

// For preview playback
const previewEls = {
  bell: document.getElementById("audio-bell"),
  bowl: document.getElementById("audio-bowl"),
};

// Decoded AudioBuffers for building the composite track
const decodedBuffers = {};

let selectedSound = localStorage.getItem("dinger-sound") || "bell";
let swRegistration = null;

// --- Service Worker ---
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js").then(reg => {
    swRegistration = reg;
  });
}

// --- Restore settings ---
const intervalInput = document.getElementById("interval");
const dingsInput = document.getElementById("dings");

const savedInterval = localStorage.getItem("dinger-interval");
if (savedInterval) intervalInput.value = savedInterval;

const savedDings = localStorage.getItem("dinger-dings");
if (savedDings) dingsInput.value = savedDings;

intervalInput.addEventListener("change", () => {
  localStorage.setItem("dinger-interval", intervalInput.value);
});
dingsInput.addEventListener("change", () => {
  localStorage.setItem("dinger-dings", dingsInput.value);
});

// --- Decode audio files upfront ---
async function decodeSound(key) {
  const resp = await fetch(SOUND_URLS[key]);
  const arrayBuf = await resp.arrayBuffer();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  decodedBuffers[key] = await audioCtx.decodeAudioData(arrayBuf);
  audioCtx.close();
}

// Decode both sounds on load
decodeSound("bell");
decodeSound("bowl");

function selectSound(key) {
  selectedSound = key;
  localStorage.setItem("dinger-sound", key);
  document.querySelectorAll(".sound-btn").forEach(b => {
    b.classList.toggle("selected", b.dataset.sound === key);
  });
}

document.querySelectorAll(".sound-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    selectSound(btn.dataset.sound);
    previewEls[btn.dataset.sound].currentTime = 0;
    previewEls[btn.dataset.sound].play();
  });
});

selectSound(selectedSound);

function showNotification() {
  if (!swRegistration || Notification.permission !== "granted") return;
  swRegistration.showNotification("Dinger", {
    body: SOUND_LABELS[selectedSound],
    tag: "dinger-bell",
    vibrate: [200, 100, 200],
    renotify: true,
  });
}

// --- Composite track playback ---
let audioCtx = null;
let sourceNode = null;
let playbackStartTime = 0;
let dingTimesSeconds = [];  // timestamps within the track where each ding occurs
let totalDings = 0;
let lastNotifiedDing = -1;
let countdownId = null;
let wakeLock = null;

async function requestWakeLock() {
  if ("wakeLock" in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => { wakeLock = null; });
    } catch (e) {
      // Wake Lock request can fail (e.g. low battery, background tab)
    }
  }
}

function releaseWakeLock() {
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
  }
}

const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const statusEl = document.getElementById("status");
const countdownEl = document.getElementById("countdown");
const progressEl = document.getElementById("ding-progress");

function buildCompositeBuffer(clipBuffer, intervalSec, count) {
  const sampleRate = clipBuffer.sampleRate;
  const channels = clipBuffer.numberOfChannels;
  const clipLen = clipBuffer.length;
  const intervalSamples = Math.round(intervalSec * sampleRate);

  // Dings at t=interval, t=2*interval, t=3*interval, ...
  // Total length = count*interval + clipLength
  const totalSamples = count * intervalSamples + clipLen;

  const composite = new AudioBuffer({
    numberOfChannels: channels,
    length: totalSamples,
    sampleRate: sampleRate,
  });

  dingTimesSeconds = [];

  for (let i = 0; i < count; i++) {
    const offsetSamples = (i + 1) * intervalSamples;
    dingTimesSeconds.push(offsetSamples / sampleRate);
    for (let ch = 0; ch < channels; ch++) {
      const src = clipBuffer.getChannelData(ch);
      const dst = composite.getChannelData(ch);
      // Copy clip samples, clamping to buffer bounds
      const copyLen = Math.min(clipLen, totalSamples - offsetSamples);
      for (let s = 0; s < copyLen; s++) {
        dst[offsetSamples + s] += src[s];
      }
    }
  }

  return composite;
}

function formatCountdown(sec) {
  if (sec <= 0) return "0:00";
  const totalSec = Math.ceil(sec);
  const m = Math.floor(totalSec / 60);
  const s = totalSec % 60;
  return m + ":" + String(s).padStart(2, "0");
}

function updateProgress() {
  if (!audioCtx || !sourceNode) return;
  const elapsed = audioCtx.currentTime - playbackStartTime;

  // Find the next ding
  let nextDingIdx = -1;
  for (let i = 0; i < dingTimesSeconds.length; i++) {
    if (dingTimesSeconds[i] > elapsed + 0.5) {
      nextDingIdx = i;
      break;
    }
  }

  // Fire notifications for dings we've passed
  for (let i = 0; i < dingTimesSeconds.length; i++) {
    if (i > lastNotifiedDing && elapsed >= dingTimesSeconds[i]) {
      lastNotifiedDing = i;
      showNotification();
    }
  }

  if (nextDingIdx >= 0) {
    const remaining = dingTimesSeconds[nextDingIdx] - elapsed;
    countdownEl.textContent = formatCountdown(remaining);
    progressEl.textContent = (nextDingIdx) + " / " + totalDings;
  } else {
    // All dings have played, show time until track ends
    const trackDuration = dingTimesSeconds[dingTimesSeconds.length - 1];
    // After last ding, just show done count
    progressEl.textContent = totalDings + " / " + totalDings;
    countdownEl.textContent = "";
  }
}

async function start() {
  const minutes = parseFloat(intervalInput.value);
  const count = parseInt(dingsInput.value);
  if (isNaN(minutes) || minutes <= 0 || isNaN(count) || count < 1) return;

  localStorage.setItem("dinger-interval", intervalInput.value);
  localStorage.setItem("dinger-dings", dingsInput.value);

  const clipBuffer = decodedBuffers[selectedSound];
  if (!clipBuffer) {
    statusEl.textContent = "loading sounds...";
    await decodeSound(selectedSound);
    return start();
  }

  // Request notification permission
  if ("Notification" in window && Notification.permission === "default") {
    const perm = await Notification.requestPermission();
    if (perm === "denied") {
      statusEl.textContent = "notifications denied â€” audio only";
    }
  }

  totalDings = count;
  lastNotifiedDing = -1;

  const intervalSec = minutes * 60;
  const composite = buildCompositeBuffer(clipBuffer, intervalSec, count);

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  sourceNode = audioCtx.createBufferSource();
  sourceNode.buffer = composite;
  sourceNode.connect(audioCtx.destination);

  playbackStartTime = audioCtx.currentTime;
  sourceNode.start();

  sourceNode.onended = () => {
    stop();
  };

  countdownId = setInterval(updateProgress, 250);

  await requestWakeLock();

  startBtn.disabled = true;
  stopBtn.disabled = false;
  intervalInput.disabled = true;
  dingsInput.disabled = true;

  const totalMin = Math.round(intervalSec * (count - 1) / 60);
  statusEl.textContent = count + " " + SOUND_LABELS[selectedSound].toLowerCase() + "s over " + totalMin + " min";
}

function stop() {
  if (sourceNode) {
    try { sourceNode.stop(); } catch(e) {}
    sourceNode = null;
  }
  if (audioCtx) {
    audioCtx.close();
    audioCtx = null;
  }
  clearInterval(countdownId);
  countdownId = null;
  dingTimesSeconds = [];
  lastNotifiedDing = -1;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  intervalInput.disabled = false;
  dingsInput.disabled = false;
  statusEl.textContent = "";
  countdownEl.textContent = "";
  progressEl.textContent = "";
  releaseWakeLock();
}

startBtn.addEventListener("click", start);
stopBtn.addEventListener("click", stop);

// Resume AudioContext and re-acquire Wake Lock when page becomes visible again.
// Browsers suspend AudioContext when the tab is hidden or the device sleeps,
// which causes the timer to lose time.
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && audioCtx) {
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }
    // Wake Lock is released when the page goes hidden; re-acquire it
    if (!wakeLock) {
      requestWakeLock();
    }
  }
});
</script>
</body>
</html>
